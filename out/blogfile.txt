
博客园logo
会员
众包
新闻
博问
闪存
赞助商
HarmonyOS
Chat2DB
代码改变世界
搜索
注册
登录
poemyang
为什么我的应用会卡顿？垃圾回收中的STW难题与破解之道
合集 - 技术札纪——有限硬件与无限计算的权衡艺术(50)
1.
书本介绍：技术札纪——有限硬件与无限计算的权衡艺术
07-24
2.
书本大纲：从芯片、分布式到云计算AI时代
07-25
3.
我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？
07-25
4.
我的代码出现幻觉？说好的a = 1； x = b，怎么成了x = b； a = 1？
07-28
5.
为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”
07-29
6.
没有Happens-Before？你的多线程代码就是‘一锅粥’！
07-30
7.
Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法
07-31
8.
a+b=c，处理器一步搞定，Java虚拟机为啥要四步？
08-01
9.
“同声传译”还是“全文翻译”？为何HotSpot虚拟机仍要保留解释器？
08-04
10.
“代码跑着跑着，就变快了？”——揭秘Java性能幕后引擎：即时编译器
08-05
11.
Java编译器优化秘籍：字节码背后的IR魔法与常见技巧
08-06
12.
解锁硬件潜能：Java向量化计算，性能飙升W倍！
08-07
13.
new出来的对象，不一定在堆上？聊聊Java虚拟机的优化技术：逃逸分析
08-08
14.
性能优化之母：为什么说“方法内联”是编译器优化中最关键的一步棋？
08-11
15.
从纳秒到毫秒的“时空之旅”：CPU是如何看待内存与硬盘的？
08-12
16.
硬盘性能提升100倍的秘密：看懂顺序I/O的魔力
08-14
17.
十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解
08-18
18.
Facebook内部都在用的存储引擎，LSM凭什么能硬扛亿级写入流量？
08-21
19.
千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！
08-22
20.
RPC的三大问题：跨语言、跨平台通信的终极解决方案是如何炼成的？
08-27
21.
从文本到二进制：HTTP/2不止于性能，更是对HTTP/1核心语义的传承与革新
08-28
22.
从HPACK到多路复用，揭秘HTTP/2如何终结网络拥堵
08-29
23.
站在巨人的肩膀上：gRPC通过HTTP/2构建云原生时代的通信标准
09-01
24.
gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？
09-03
25.
从JSON到Protobuf，深入序列化方案的选型与原理
09-04
26.
“卧槽，系统又崩了！”——别慌，这也许是你看过最通俗易懂的分布式入门
09-05
27.
海量数据如何“安家”？一文读懂哈希、范围和一致性哈希三大分片策略
09-08
28.
“你还活着吗？” “我没死，只是网卡了！”——来自分布式世界的“生死契约”
09-09
29.
“凭什么说你比我先？”——没有上帝时钟，如何判断“谁先谁后”？
09-12
30.
“鸡蛋不能放一个篮子里”，如何确保千亿数据万无一失？
09-15
31.
系统里数据又“打架”了？让“少数服从多数”来终结这场混乱！
09-18
32.
技术圈的“绯闻女孩”：Gossip是如何把八卦秘密传遍全网的？
09-19
33.
绯闻女孩不只会八卦：从“验明正身”到“抓内鬼”，Gossip的进阶玩法
09-20
34.
从混沌到秩序：Java共享内存模型如何通过显式约束驯服并发？
09-23
35.
一把锁的两种承诺：synchronized如何同时保证互斥与内存可见性？
09-24
36.
从MESA模型到锁升级：synchronized性能逆袭的底层逻辑
09-25
37.
揭秘JUC：volatile与CAS，并发编程的两大基石
09-27
38.
“不要通过共享内存来通信”——深入理解Golang并发模型与CSP理论
10-13
39.
Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
10-14
40.
“一切皆文件”：揭秘LINUX I/O与虚拟内存的底层设计哲学
10-15
41.
你的程序为何卡顿？从LINUX I/O三大模式寻找答案
10-16
42.
单线程如何撑起百万连接？I/O多路复用：现代网络架构的基石
10-17
43.
从C10K到Reactor：事件驱动，如何重塑高并发服务器的网络架构
10-20
44.
职责分离的艺术：剖析主从Reactor模型如何实现极致的并发性能
10-21
45.
“化零为整”的智慧：内存池如何绕过系统调用和GC，构建性能的护城河
10-22
46.
jemalloc思想的极致演绎：深度解构Netty内存池的精妙设计与实现
10-23
47.
为什么Java/Python程序无需关心内存释放？揭秘垃圾回收（GC）的核心概念
10-25
48.
压缩指针：64位系统下，Java虚拟机是如何“偷”回4字节内存的？
10-27
49.
谁生？谁死？从引用计数到可达性分析，洞悉GC的决策逻辑
10-29
50.
为什么我的应用会卡顿？垃圾回收中的STW难题与破解之道
10-30
收起
垃圾回收算法：清除、压缩、复制
可达性分析提供了一种有效的方式，来标记哪些对象死亡，哪些对象还存活。然而，确定哪些对象死亡可以被回收，只是垃圾回收的第一步， 这个过程通常被称为标记（Mark）。接下来，需要一种方法来回收这些死亡对象占用的内存，以便这些内存可以被重新使用。这就是垃圾回收算法的任务。
垃圾回收算法描述了如何有效地回收垃圾对象的内存，同时尽量减少对程序执行的影响。

清除
清除（Sweep）算法的主要操作是将不再活跃的对象的内存标记为可用，并将这些内存信息记录在一个叫做空闲列表（Free List）的数据结构中。当程序需要实例化新的对象时，内存管理模块会从空闲列表中找到可用的内存空间，分配给新对象。
清除算法的主要缺点是可能导致内存碎片化。因为在堆内存中，对象的存储必须是连续的，可能会出现总的空闲内存充足，但无法找到足够大的连续内存空间来存储新的对象的情况。
另一个缺点是清除策略的内存分配效率较低。如果内存是连续的空间，可以通过简单的指针运算，比如指针加法（Pointer Bumping），快速分配内存。但对于清除算法中的空闲列表，需要逐一检查列表中的每一项，找到足够大的空闲内存来存储新的对象，这个过程相对耗时
image

压缩
压缩（Compact）算法的主要操作是将所有存活的对象移动至内存的一端，使这些对象在内存中连续排列，并更新所有指向这些对象的引用。这样，所有未被标记的对象都被挤压到内存的另一端，可以一次性回收。
压缩算法的优点是可以避免内存碎片，因为所有活动对象在压缩时都被紧凑排列。此外，这种算法不需要额外的内存空间，因为所有操作都在原地完成。
然而，压缩算法也有缺点。首先，压缩可能改变对象在内存中的位置，可能影响程序性能。其次，如果活动对象占据了大部分内存，压缩过程可能会非常耗时。
image

复制
复制（Copy）算法的主要操作是将所有活动的对象复制到内存的另一部分（通常称为to-space），并更新所有指向这些对象的引用。复制后，原来的内存区域（即from-space）中的所有对象都被视为垃圾，可以一次性回收。
复制算法的优势在于避免内存碎片，因为所有活动对象在复制时都被紧凑排列。此外，由于只处理活动对象，所以当大部分内存被垃圾对象占据时，此算法效率高。
然而，复制算法也有缺点。首先，它需要额外内存空间存放复制的对象。其次，复制过程可能改变对象在内存中的位置，可能影响程序性能。
image

并发标记：与时间赛跑的追踪游戏
标记阶段是所有追踪式垃圾回收算法的共同特征，这个阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾回收过程，同理可知，如果能够削减这部分停顿时间的话，那收益也将会是系统性的。
为了解决原始标记阶段带来的长时间停顿，多数现代的追踪式垃圾回收算法都会实现三色标记（Tri-color Marking）算法的变种以缩短停顿的时间。三色标记算法将程序中的对象分成白色、黑色和灰色三类。
1）白色对象：不活动对象，没有被其他对象引用，或者从根节点开始无法到达的对象；
2）灰色对象：活动对象，被其他对象引用，或者从根节点开始可以到达的对象。但是，这些对象引用的对象还没有被检查；
3）黑色对象：活动对象，从根节点开始可以到达的对象，而且这些对象引用的对象都已经被检查过了。
image

在垃圾回收过程中，首先将所有对象标记为白色，然后从根节点开始，将可达的对象标记为灰色，然后逐步将灰色对象标记为黑色，并将它们引用的对象标记为灰色。这个过程一直持续到所有活动对象都被标记为黑色，所有不活动对象都被标记为白色。

image

三色标记算法在并发环境下可能会出现问题，这个问题被称为“并发标记的漏标问题”。如下图所示的三色标记过程中，用户程序重新建立了从A对象到D对象的引用，但是因为程序中已经不存在灰色对象了，导致D对象本应被标记为灰色，而被错误地标记为白色，从而在垃圾回收时被错误地回收。

image

为了解决这个问题，可以使用写屏障（Write Barrier）技术。写屏障像是一个钩子方法，当一个对象的引用被修改时，会触发执行一段指令代码，将这个对象重新标记为灰色，以确保不会错过任何需要被标记的对象。这样，就可以在并发环境下正确地进行垃圾回收。

image

增量更新（Incremental Update）和快照在写时复制（Snapshot At The Beginning, SATB）都是垃圾回收中的写屏障技术，但是，它们在处理方式上有所不同。
1）增量更新：写屏障被触发时，如果一个黑色对象引用了一个白色对象，那么这个白色对象会被立即标记为灰色。
2）快照在写时复制：写屏障被触发时，会记录下被修改的引用，而不是立即修改对象的颜色。然后在并发标记结束时，根据这些记录，重新标记那些被错误地标记为非活动对象。

未完待续

很高兴与你相遇！如果你喜欢本文内容，记得关注哦

本文来自博客园，作者：poemyang，转载请注明原文链接：https://www.cnblogs.com/poemyang/p/19176615

合集: 技术札纪——有限硬件与无限计算的权衡艺术
分类: Java虚拟机
标签: java虚拟机, 垃圾回收
好文要顶 关注我 收藏该文 微信分享
poemyang
粉丝 - 21 关注 - 0
+加关注
00
升级成为会员
« 上一篇： 谁生？谁死？从引用计数到可达性分析，洞悉GC的决策逻辑
posted on 2025-10-30 12:16  poemyang  阅读(29)  评论(0)    收藏  举报

刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】鸿蒙应用开发者激励计划，开发上架应用，现金激励超亿元！
【推荐】博客园&小马算力达成战略合作，为开发者注入“算力引擎”
【推荐】2025 HarmonyOS 创新赛正式启动，百万大奖等你来挑战！
【推荐】天翼云智惠上云月，爆款云主机2核2G只要18.8元/3个月起

编辑推荐：
Web优化躬行记（7）——后台上传大批量图优化
从18w到1600w播放量，我的一点思考
从一个普通程序员的角度，聊聊当前环境下，是否还适合做编程
史诗级警报：ASP.NET Core 被曝 CVSS 9.9 分漏洞
一个轻量级C++内存监控及可视化开源库
鸿蒙专区：
开发上架鸿蒙应用，现金激励超亿元！
前端转鸿蒙开发几个比较难受的地方
闯入鸿蒙：浪漫、理想与「草台班子」
3天赚2万！开发者的梦想也可以掷地有声！
Flutter 适配 HarmonyOS 5 开发知识地图
博客园  ©  2004-2025
浙公网安备 33010602011771号 浙ICP备2021040463号-3

<	2025年10月	>
日	一	二	三	四	五	六
28	29	30	1	2	3	4
5	6	7	8	9	10	11
12	13	14	15	16	17	18
19	20	21	22	23	24	25
26	27	28	29	30	31	1
2	3	4	5	6	7	8
导航
博客园
首页
新随笔
联系
订阅 订阅
管理
统计
随笔 - 50
文章 - 0
评论 - 6
阅读 - 20261
公告
昵称： poemyang
园龄： 10年5个月
粉丝： 21
关注： 0
+加关注

搜索
 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
我的标签
rpc(13)
java虚拟机(12)
并发编程(9)
java并发编程(8)
编译原理(7)
java(6)
分布式(6)
网络协议(5)
分布式系统(5)
多线程(5)
更多
合集
技术札纪——有限硬件与无限计算的权衡艺术(50)
随笔分类
Java虚拟机(12)
RPC框架(13)
并发编程艺术(9)
分布式系统之美(8)
高并发系统设计(5)
随笔档案
2025年10月(13)
2025年9月(15)
2025年8月(15)
2025年7月(7)
阅读排行榜
1. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(1819)
2. 为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”(1213)
3. 我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？(828)
4. Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法(787)
5. 硬盘性能提升100倍的秘密：看懂顺序I/O的魔力(739)
评论排行榜
1. Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？(2)
2. 从MESA模型到锁升级：synchronized性能逆袭的底层逻辑(1)
3. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(1)
4. 解锁硬件潜能：Java向量化计算，性能飙升W倍！(1)
5. Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法(1)
推荐排行榜
1. 从JSON到Protobuf，深入序列化方案的选型与原理(3)
2. gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？(2)
3. 千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！(2)
4. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(2)
5. 硬盘性能提升100倍的秘密：看懂顺序I/O的魔力(2)
最新评论
1. Re:Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
@楊柳 msb 是指？...
--poemyang
2. Re:Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
这篇比msb讲的更容易懂点

--楊柳
3. Re:从MESA模型到锁升级：synchronized性能逆袭的底层逻辑
MESA 拼错了，应该是 MESI

--清香白莲素还真
4. Re:十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解
（：笑。难道不是扩容加资源吗

--如晚风说
5. Re:解锁硬件潜能：Java向量化计算，性能飙升W倍！
现在编译器都基本上显式的提供了SIMD指令支持，像新版的C#，也有向量化的指令，不过真正要灵活运用，做到效率极致还是最好用C++处理SIMD指令。

--Imageshop


博客园logo
会员
众包
新闻
博问
闪存
赞助商
HarmonyOS
Chat2DB
代码改变世界
搜索
注册
登录
poemyang
为什么我的应用会卡顿？垃圾回收中的STW难题与破解之道
合集 - 技术札纪——有限硬件与无限计算的权衡艺术(50)
1.
书本介绍：技术札纪——有限硬件与无限计算的权衡艺术
07-24
2.
书本大纲：从芯片、分布式到云计算AI时代
07-25
3.
我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？
07-25
4.
我的代码出现幻觉？说好的a = 1； x = b，怎么成了x = b； a = 1？
07-28
5.
为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”
07-29
6.
没有Happens-Before？你的多线程代码就是‘一锅粥’！
07-30
7.
Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法
07-31
8.
a+b=c，处理器一步搞定，Java虚拟机为啥要四步？
08-01
9.
“同声传译”还是“全文翻译”？为何HotSpot虚拟机仍要保留解释器？
08-04
10.
“代码跑着跑着，就变快了？”——揭秘Java性能幕后引擎：即时编译器
08-05
11.
Java编译器优化秘籍：字节码背后的IR魔法与常见技巧
08-06
12.
解锁硬件潜能：Java向量化计算，性能飙升W倍！
08-07
13.
new出来的对象，不一定在堆上？聊聊Java虚拟机的优化技术：逃逸分析
08-08
14.
性能优化之母：为什么说“方法内联”是编译器优化中最关键的一步棋？
08-11
15.
从纳秒到毫秒的“时空之旅”：CPU是如何看待内存与硬盘的？
08-12
16.
硬盘性能提升100倍的秘密：看懂顺序I/O的魔力
08-14
17.
十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解
08-18
18.
Facebook内部都在用的存储引擎，LSM凭什么能硬扛亿级写入流量？
08-21
19.
千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！
08-22
20.
RPC的三大问题：跨语言、跨平台通信的终极解决方案是如何炼成的？
08-27
21.
从文本到二进制：HTTP/2不止于性能，更是对HTTP/1核心语义的传承与革新
08-28
22.
从HPACK到多路复用，揭秘HTTP/2如何终结网络拥堵
08-29
23.
站在巨人的肩膀上：gRPC通过HTTP/2构建云原生时代的通信标准
09-01
24.
gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？
09-03
25.
从JSON到Protobuf，深入序列化方案的选型与原理
09-04
26.
“卧槽，系统又崩了！”——别慌，这也许是你看过最通俗易懂的分布式入门
09-05
27.
海量数据如何“安家”？一文读懂哈希、范围和一致性哈希三大分片策略
09-08
28.
“你还活着吗？” “我没死，只是网卡了！”——来自分布式世界的“生死契约”
09-09
29.
“凭什么说你比我先？”——没有上帝时钟，如何判断“谁先谁后”？
09-12
30.
“鸡蛋不能放一个篮子里”，如何确保千亿数据万无一失？
09-15
31.
系统里数据又“打架”了？让“少数服从多数”来终结这场混乱！
09-18
32.
技术圈的“绯闻女孩”：Gossip是如何把八卦秘密传遍全网的？
09-19
33.
绯闻女孩不只会八卦：从“验明正身”到“抓内鬼”，Gossip的进阶玩法
09-20
34.
从混沌到秩序：Java共享内存模型如何通过显式约束驯服并发？
09-23
35.
一把锁的两种承诺：synchronized如何同时保证互斥与内存可见性？
09-24
36.
从MESA模型到锁升级：synchronized性能逆袭的底层逻辑
09-25
37.
揭秘JUC：volatile与CAS，并发编程的两大基石
09-27
38.
“不要通过共享内存来通信”——深入理解Golang并发模型与CSP理论
10-13
39.
Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
10-14
40.
“一切皆文件”：揭秘LINUX I/O与虚拟内存的底层设计哲学
10-15
41.
你的程序为何卡顿？从LINUX I/O三大模式寻找答案
10-16
42.
单线程如何撑起百万连接？I/O多路复用：现代网络架构的基石
10-17
43.
从C10K到Reactor：事件驱动，如何重塑高并发服务器的网络架构
10-20
44.
职责分离的艺术：剖析主从Reactor模型如何实现极致的并发性能
10-21
45.
“化零为整”的智慧：内存池如何绕过系统调用和GC，构建性能的护城河
10-22
46.
jemalloc思想的极致演绎：深度解构Netty内存池的精妙设计与实现
10-23
47.
为什么Java/Python程序无需关心内存释放？揭秘垃圾回收（GC）的核心概念
10-25
48.
压缩指针：64位系统下，Java虚拟机是如何“偷”回4字节内存的？
10-27
49.
谁生？谁死？从引用计数到可达性分析，洞悉GC的决策逻辑
10-29
50.
为什么我的应用会卡顿？垃圾回收中的STW难题与破解之道
10-30
收起
垃圾回收算法：清除、压缩、复制
可达性分析提供了一种有效的方式，来标记哪些对象死亡，哪些对象还存活。然而，确定哪些对象死亡可以被回收，只是垃圾回收的第一步， 这个过程通常被称为标记（Mark）。接下来，需要一种方法来回收这些死亡对象占用的内存，以便这些内存可以被重新使用。这就是垃圾回收算法的任务。
垃圾回收算法描述了如何有效地回收垃圾对象的内存，同时尽量减少对程序执行的影响。

清除
清除（Sweep）算法的主要操作是将不再活跃的对象的内存标记为可用，并将这些内存信息记录在一个叫做空闲列表（Free List）的数据结构中。当程序需要实例化新的对象时，内存管理模块会从空闲列表中找到可用的内存空间，分配给新对象。
清除算法的主要缺点是可能导致内存碎片化。因为在堆内存中，对象的存储必须是连续的，可能会出现总的空闲内存充足，但无法找到足够大的连续内存空间来存储新的对象的情况。
另一个缺点是清除策略的内存分配效率较低。如果内存是连续的空间，可以通过简单的指针运算，比如指针加法（Pointer Bumping），快速分配内存。但对于清除算法中的空闲列表，需要逐一检查列表中的每一项，找到足够大的空闲内存来存储新的对象，这个过程相对耗时
image

压缩
压缩（Compact）算法的主要操作是将所有存活的对象移动至内存的一端，使这些对象在内存中连续排列，并更新所有指向这些对象的引用。这样，所有未被标记的对象都被挤压到内存的另一端，可以一次性回收。
压缩算法的优点是可以避免内存碎片，因为所有活动对象在压缩时都被紧凑排列。此外，这种算法不需要额外的内存空间，因为所有操作都在原地完成。
然而，压缩算法也有缺点。首先，压缩可能改变对象在内存中的位置，可能影响程序性能。其次，如果活动对象占据了大部分内存，压缩过程可能会非常耗时。
image

复制
复制（Copy）算法的主要操作是将所有活动的对象复制到内存的另一部分（通常称为to-space），并更新所有指向这些对象的引用。复制后，原来的内存区域（即from-space）中的所有对象都被视为垃圾，可以一次性回收。
复制算法的优势在于避免内存碎片，因为所有活动对象在复制时都被紧凑排列。此外，由于只处理活动对象，所以当大部分内存被垃圾对象占据时，此算法效率高。
然而，复制算法也有缺点。首先，它需要额外内存空间存放复制的对象。其次，复制过程可能改变对象在内存中的位置，可能影响程序性能。
image

并发标记：与时间赛跑的追踪游戏
标记阶段是所有追踪式垃圾回收算法的共同特征，这个阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾回收过程，同理可知，如果能够削减这部分停顿时间的话，那收益也将会是系统性的。
为了解决原始标记阶段带来的长时间停顿，多数现代的追踪式垃圾回收算法都会实现三色标记（Tri-color Marking）算法的变种以缩短停顿的时间。三色标记算法将程序中的对象分成白色、黑色和灰色三类。
1）白色对象：不活动对象，没有被其他对象引用，或者从根节点开始无法到达的对象；
2）灰色对象：活动对象，被其他对象引用，或者从根节点开始可以到达的对象。但是，这些对象引用的对象还没有被检查；
3）黑色对象：活动对象，从根节点开始可以到达的对象，而且这些对象引用的对象都已经被检查过了。
image

在垃圾回收过程中，首先将所有对象标记为白色，然后从根节点开始，将可达的对象标记为灰色，然后逐步将灰色对象标记为黑色，并将它们引用的对象标记为灰色。这个过程一直持续到所有活动对象都被标记为黑色，所有不活动对象都被标记为白色。

image

三色标记算法在并发环境下可能会出现问题，这个问题被称为“并发标记的漏标问题”。如下图所示的三色标记过程中，用户程序重新建立了从A对象到D对象的引用，但是因为程序中已经不存在灰色对象了，导致D对象本应被标记为灰色，而被错误地标记为白色，从而在垃圾回收时被错误地回收。

image

为了解决这个问题，可以使用写屏障（Write Barrier）技术。写屏障像是一个钩子方法，当一个对象的引用被修改时，会触发执行一段指令代码，将这个对象重新标记为灰色，以确保不会错过任何需要被标记的对象。这样，就可以在并发环境下正确地进行垃圾回收。

image

增量更新（Incremental Update）和快照在写时复制（Snapshot At The Beginning, SATB）都是垃圾回收中的写屏障技术，但是，它们在处理方式上有所不同。
1）增量更新：写屏障被触发时，如果一个黑色对象引用了一个白色对象，那么这个白色对象会被立即标记为灰色。
2）快照在写时复制：写屏障被触发时，会记录下被修改的引用，而不是立即修改对象的颜色。然后在并发标记结束时，根据这些记录，重新标记那些被错误地标记为非活动对象。

未完待续

很高兴与你相遇！如果你喜欢本文内容，记得关注哦

本文来自博客园，作者：poemyang，转载请注明原文链接：https://www.cnblogs.com/poemyang/p/19176615

合集: 技术札纪——有限硬件与无限计算的权衡艺术
分类: Java虚拟机
标签: java虚拟机, 垃圾回收
好文要顶 关注我 收藏该文 微信分享
poemyang
粉丝 - 21 关注 - 0
+加关注
00
升级成为会员
« 上一篇： 谁生？谁死？从引用计数到可达性分析，洞悉GC的决策逻辑
posted on 2025-10-30 12:16  poemyang  阅读(29)  评论(0)    收藏  举报

刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】鸿蒙应用开发者激励计划，开发上架应用，现金激励超亿元！
【推荐】博客园&小马算力达成战略合作，为开发者注入“算力引擎”
【推荐】2025 HarmonyOS 创新赛正式启动，百万大奖等你来挑战！
【推荐】天翼云智惠上云月，爆款云主机2核2G只要18.8元/3个月起

编辑推荐：
Web优化躬行记（7）——后台上传大批量图优化
从18w到1600w播放量，我的一点思考
从一个普通程序员的角度，聊聊当前环境下，是否还适合做编程
史诗级警报：ASP.NET Core 被曝 CVSS 9.9 分漏洞
一个轻量级C++内存监控及可视化开源库
鸿蒙专区：
开发上架鸿蒙应用，现金激励超亿元！
前端转鸿蒙开发几个比较难受的地方
闯入鸿蒙：浪漫、理想与「草台班子」
3天赚2万！开发者的梦想也可以掷地有声！
Flutter 适配 HarmonyOS 5 开发知识地图
博客园  ©  2004-2025
浙公网安备 33010602011771号 浙ICP备2021040463号-3

<	2025年10月	>
日	一	二	三	四	五	六
28	29	30	1	2	3	4
5	6	7	8	9	10	11
12	13	14	15	16	17	18
19	20	21	22	23	24	25
26	27	28	29	30	31	1
2	3	4	5	6	7	8
导航
博客园
首页
新随笔
联系
订阅 订阅
管理
统计
随笔 - 50
文章 - 0
评论 - 6
阅读 - 20261
公告
昵称： poemyang
园龄： 10年5个月
粉丝： 21
关注： 0
+加关注

搜索
 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
我的标签
rpc(13)
java虚拟机(12)
并发编程(9)
java并发编程(8)
编译原理(7)
java(6)
分布式(6)
网络协议(5)
分布式系统(5)
多线程(5)
更多
合集
技术札纪——有限硬件与无限计算的权衡艺术(50)
随笔分类
Java虚拟机(12)
RPC框架(13)
并发编程艺术(9)
分布式系统之美(8)
高并发系统设计(5)
随笔档案
2025年10月(13)
2025年9月(15)
2025年8月(15)
2025年7月(7)
阅读排行榜
1. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(1819)
2. 为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”(1213)
3. 我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？(828)
4. Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法(787)
5. 硬盘性能提升100倍的秘密：看懂顺序I/O的魔力(739)
评论排行榜
1. Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？(2)
2. 从MESA模型到锁升级：synchronized性能逆袭的底层逻辑(1)
3. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(1)
4. 解锁硬件潜能：Java向量化计算，性能飙升W倍！(1)
5. Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法(1)
推荐排行榜
1. 从JSON到Protobuf，深入序列化方案的选型与原理(3)
2. gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？(2)
3. 千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！(2)
4. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(2)
5. 硬盘性能提升100倍的秘密：看懂顺序I/O的魔力(2)
最新评论
1. Re:Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
@楊柳 msb 是指？...
--poemyang
2. Re:Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
这篇比msb讲的更容易懂点

--楊柳
3. Re:从MESA模型到锁升级：synchronized性能逆袭的底层逻辑
MESA 拼错了，应该是 MESI

--清香白莲素还真
4. Re:十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解
（：笑。难道不是扩容加资源吗

--如晚风说
5. Re:解锁硬件潜能：Java向量化计算，性能飙升W倍！
现在编译器都基本上显式的提供了SIMD指令支持，像新版的C#，也有向量化的指令，不过真正要灵活运用，做到效率极致还是最好用C++处理SIMD指令。

--Imageshop

博客园logo
会员
众包
新闻
博问
闪存
赞助商
HarmonyOS
Chat2DB
代码改变世界
搜索
注册
登录
poemyang
为什么我的应用会卡顿？垃圾回收中的STW难题与破解之道
合集 - 技术札纪——有限硬件与无限计算的权衡艺术(50)
1.
书本介绍：技术札纪——有限硬件与无限计算的权衡艺术
07-24
2.
书本大纲：从芯片、分布式到云计算AI时代
07-25
3.
我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？
07-25
4.
我的代码出现幻觉？说好的a = 1； x = b，怎么成了x = b； a = 1？
07-28
5.
为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”
07-29
6.
没有Happens-Before？你的多线程代码就是‘一锅粥’！
07-30
7.
Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法
07-31
8.
a+b=c，处理器一步搞定，Java虚拟机为啥要四步？
08-01
9.
“同声传译”还是“全文翻译”？为何HotSpot虚拟机仍要保留解释器？
08-04
10.
“代码跑着跑着，就变快了？”——揭秘Java性能幕后引擎：即时编译器
08-05
11.
Java编译器优化秘籍：字节码背后的IR魔法与常见技巧
08-06
12.
解锁硬件潜能：Java向量化计算，性能飙升W倍！
08-07
13.
new出来的对象，不一定在堆上？聊聊Java虚拟机的优化技术：逃逸分析
08-08
14.
性能优化之母：为什么说“方法内联”是编译器优化中最关键的一步棋？
08-11
15.
从纳秒到毫秒的“时空之旅”：CPU是如何看待内存与硬盘的？
08-12
16.
硬盘性能提升100倍的秘密：看懂顺序I/O的魔力
08-14
17.
十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解
08-18
18.
Facebook内部都在用的存储引擎，LSM凭什么能硬扛亿级写入流量？
08-21
19.
千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！
08-22
20.
RPC的三大问题：跨语言、跨平台通信的终极解决方案是如何炼成的？
08-27
21.
从文本到二进制：HTTP/2不止于性能，更是对HTTP/1核心语义的传承与革新
08-28
22.
从HPACK到多路复用，揭秘HTTP/2如何终结网络拥堵
08-29
23.
站在巨人的肩膀上：gRPC通过HTTP/2构建云原生时代的通信标准
09-01
24.
gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？
09-03
25.
从JSON到Protobuf，深入序列化方案的选型与原理
09-04
26.
“卧槽，系统又崩了！”——别慌，这也许是你看过最通俗易懂的分布式入门
09-05
27.
海量数据如何“安家”？一文读懂哈希、范围和一致性哈希三大分片策略
09-08
28.
“你还活着吗？” “我没死，只是网卡了！”——来自分布式世界的“生死契约”
09-09
29.
“凭什么说你比我先？”——没有上帝时钟，如何判断“谁先谁后”？
09-12
30.
“鸡蛋不能放一个篮子里”，如何确保千亿数据万无一失？
09-15
31.
系统里数据又“打架”了？让“少数服从多数”来终结这场混乱！
09-18
32.
技术圈的“绯闻女孩”：Gossip是如何把八卦秘密传遍全网的？
09-19
33.
绯闻女孩不只会八卦：从“验明正身”到“抓内鬼”，Gossip的进阶玩法
09-20
34.
从混沌到秩序：Java共享内存模型如何通过显式约束驯服并发？
09-23
35.
一把锁的两种承诺：synchronized如何同时保证互斥与内存可见性？
09-24
36.
从MESA模型到锁升级：synchronized性能逆袭的底层逻辑
09-25
37.
揭秘JUC：volatile与CAS，并发编程的两大基石
09-27
38.
“不要通过共享内存来通信”——深入理解Golang并发模型与CSP理论
10-13
39.
Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
10-14
40.
“一切皆文件”：揭秘LINUX I/O与虚拟内存的底层设计哲学
10-15
41.
你的程序为何卡顿？从LINUX I/O三大模式寻找答案
10-16
42.
单线程如何撑起百万连接？I/O多路复用：现代网络架构的基石
10-17
43.
从C10K到Reactor：事件驱动，如何重塑高并发服务器的网络架构
10-20
44.
职责分离的艺术：剖析主从Reactor模型如何实现极致的并发性能
10-21
45.
“化零为整”的智慧：内存池如何绕过系统调用和GC，构建性能的护城河
10-22
46.
jemalloc思想的极致演绎：深度解构Netty内存池的精妙设计与实现
10-23
47.
为什么Java/Python程序无需关心内存释放？揭秘垃圾回收（GC）的核心概念
10-25
48.
压缩指针：64位系统下，Java虚拟机是如何“偷”回4字节内存的？
10-27
49.
谁生？谁死？从引用计数到可达性分析，洞悉GC的决策逻辑
10-29
50.
为什么我的应用会卡顿？垃圾回收中的STW难题与破解之道
10-30
收起
垃圾回收算法：清除、压缩、复制
可达性分析提供了一种有效的方式，来标记哪些对象死亡，哪些对象还存活。然而，确定哪些对象死亡可以被回收，只是垃圾回收的第一步， 这个过程通常被称为标记（Mark）。接下来，需要一种方法来回收这些死亡对象占用的内存，以便这些内存可以被重新使用。这就是垃圾回收算法的任务。
垃圾回收算法描述了如何有效地回收垃圾对象的内存，同时尽量减少对程序执行的影响。

清除
清除（Sweep）算法的主要操作是将不再活跃的对象的内存标记为可用，并将这些内存信息记录在一个叫做空闲列表（Free List）的数据结构中。当程序需要实例化新的对象时，内存管理模块会从空闲列表中找到可用的内存空间，分配给新对象。
清除算法的主要缺点是可能导致内存碎片化。因为在堆内存中，对象的存储必须是连续的，可能会出现总的空闲内存充足，但无法找到足够大的连续内存空间来存储新的对象的情况。
另一个缺点是清除策略的内存分配效率较低。如果内存是连续的空间，可以通过简单的指针运算，比如指针加法（Pointer Bumping），快速分配内存。但对于清除算法中的空闲列表，需要逐一检查列表中的每一项，找到足够大的空闲内存来存储新的对象，这个过程相对耗时
image

压缩
压缩（Compact）算法的主要操作是将所有存活的对象移动至内存的一端，使这些对象在内存中连续排列，并更新所有指向这些对象的引用。这样，所有未被标记的对象都被挤压到内存的另一端，可以一次性回收。
压缩算法的优点是可以避免内存碎片，因为所有活动对象在压缩时都被紧凑排列。此外，这种算法不需要额外的内存空间，因为所有操作都在原地完成。
然而，压缩算法也有缺点。首先，压缩可能改变对象在内存中的位置，可能影响程序性能。其次，如果活动对象占据了大部分内存，压缩过程可能会非常耗时。
image

复制
复制（Copy）算法的主要操作是将所有活动的对象复制到内存的另一部分（通常称为to-space），并更新所有指向这些对象的引用。复制后，原来的内存区域（即from-space）中的所有对象都被视为垃圾，可以一次性回收。
复制算法的优势在于避免内存碎片，因为所有活动对象在复制时都被紧凑排列。此外，由于只处理活动对象，所以当大部分内存被垃圾对象占据时，此算法效率高。
然而，复制算法也有缺点。首先，它需要额外内存空间存放复制的对象。其次，复制过程可能改变对象在内存中的位置，可能影响程序性能。
image

并发标记：与时间赛跑的追踪游戏
标记阶段是所有追踪式垃圾回收算法的共同特征，这个阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾回收过程，同理可知，如果能够削减这部分停顿时间的话，那收益也将会是系统性的。
为了解决原始标记阶段带来的长时间停顿，多数现代的追踪式垃圾回收算法都会实现三色标记（Tri-color Marking）算法的变种以缩短停顿的时间。三色标记算法将程序中的对象分成白色、黑色和灰色三类。
1）白色对象：不活动对象，没有被其他对象引用，或者从根节点开始无法到达的对象；
2）灰色对象：活动对象，被其他对象引用，或者从根节点开始可以到达的对象。但是，这些对象引用的对象还没有被检查；
3）黑色对象：活动对象，从根节点开始可以到达的对象，而且这些对象引用的对象都已经被检查过了。
image

在垃圾回收过程中，首先将所有对象标记为白色，然后从根节点开始，将可达的对象标记为灰色，然后逐步将灰色对象标记为黑色，并将它们引用的对象标记为灰色。这个过程一直持续到所有活动对象都被标记为黑色，所有不活动对象都被标记为白色。

image

三色标记算法在并发环境下可能会出现问题，这个问题被称为“并发标记的漏标问题”。如下图所示的三色标记过程中，用户程序重新建立了从A对象到D对象的引用，但是因为程序中已经不存在灰色对象了，导致D对象本应被标记为灰色，而被错误地标记为白色，从而在垃圾回收时被错误地回收。

image

为了解决这个问题，可以使用写屏障（Write Barrier）技术。写屏障像是一个钩子方法，当一个对象的引用被修改时，会触发执行一段指令代码，将这个对象重新标记为灰色，以确保不会错过任何需要被标记的对象。这样，就可以在并发环境下正确地进行垃圾回收。

image

增量更新（Incremental Update）和快照在写时复制（Snapshot At The Beginning, SATB）都是垃圾回收中的写屏障技术，但是，它们在处理方式上有所不同。
1）增量更新：写屏障被触发时，如果一个黑色对象引用了一个白色对象，那么这个白色对象会被立即标记为灰色。
2）快照在写时复制：写屏障被触发时，会记录下被修改的引用，而不是立即修改对象的颜色。然后在并发标记结束时，根据这些记录，重新标记那些被错误地标记为非活动对象。

未完待续

很高兴与你相遇！如果你喜欢本文内容，记得关注哦

本文来自博客园，作者：poemyang，转载请注明原文链接：https://www.cnblogs.com/poemyang/p/19176615

合集: 技术札纪——有限硬件与无限计算的权衡艺术
分类: Java虚拟机
标签: java虚拟机, 垃圾回收
好文要顶 关注我 收藏该文 微信分享
poemyang
粉丝 - 21 关注 - 0
+加关注
00
升级成为会员
« 上一篇： 谁生？谁死？从引用计数到可达性分析，洞悉GC的决策逻辑
posted on 2025-10-30 12:16  poemyang  阅读(29)  评论(0)    收藏  举报

刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】鸿蒙应用开发者激励计划，开发上架应用，现金激励超亿元！
【推荐】博客园&小马算力达成战略合作，为开发者注入“算力引擎”
【推荐】2025 HarmonyOS 创新赛正式启动，百万大奖等你来挑战！
【推荐】天翼云智惠上云月，爆款云主机2核2G只要18.8元/3个月起

编辑推荐：
Web优化躬行记（7）——后台上传大批量图优化
从18w到1600w播放量，我的一点思考
从一个普通程序员的角度，聊聊当前环境下，是否还适合做编程
史诗级警报：ASP.NET Core 被曝 CVSS 9.9 分漏洞
一个轻量级C++内存监控及可视化开源库
鸿蒙专区：
开发上架鸿蒙应用，现金激励超亿元！
前端转鸿蒙开发几个比较难受的地方
闯入鸿蒙：浪漫、理想与「草台班子」
3天赚2万！开发者的梦想也可以掷地有声！
Flutter 适配 HarmonyOS 5 开发知识地图
博客园  ©  2004-2025
浙公网安备 33010602011771号 浙ICP备2021040463号-3

<	2025年10月	>
日	一	二	三	四	五	六
28	29	30	1	2	3	4
5	6	7	8	9	10	11
12	13	14	15	16	17	18
19	20	21	22	23	24	25
26	27	28	29	30	31	1
2	3	4	5	6	7	8
导航
博客园
首页
新随笔
联系
订阅 订阅
管理
统计
随笔 - 50
文章 - 0
评论 - 6
阅读 - 20261
公告
昵称： poemyang
园龄： 10年5个月
粉丝： 21
关注： 0
+加关注

搜索
 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
我的标签
rpc(13)
java虚拟机(12)
并发编程(9)
java并发编程(8)
编译原理(7)
java(6)
分布式(6)
网络协议(5)
分布式系统(5)
多线程(5)
更多
合集
技术札纪——有限硬件与无限计算的权衡艺术(50)
随笔分类
Java虚拟机(12)
RPC框架(13)
并发编程艺术(9)
分布式系统之美(8)
高并发系统设计(5)
随笔档案
2025年10月(13)
2025年9月(15)
2025年8月(15)
2025年7月(7)
阅读排行榜
1. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(1819)
2. 为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”(1213)
3. 我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？(828)
4. Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法(787)
5. 硬盘性能提升100倍的秘密：看懂顺序I/O的魔力(739)
评论排行榜
1. Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？(2)
2. 从MESA模型到锁升级：synchronized性能逆袭的底层逻辑(1)
3. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(1)
4. 解锁硬件潜能：Java向量化计算，性能飙升W倍！(1)
5. Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法(1)
推荐排行榜
1. 从JSON到Protobuf，深入序列化方案的选型与原理(3)
2. gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？(2)
3. 千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！(2)
4. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(2)
5. 硬盘性能提升100倍的秘密：看懂顺序I/O的魔力(2)
最新评论
1. Re:Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
@楊柳 msb 是指？...
--poemyang
2. Re:Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
这篇比msb讲的更容易懂点

--楊柳
3. Re:从MESA模型到锁升级：synchronized性能逆袭的底层逻辑
MESA 拼错了，应该是 MESI

--清香白莲素还真
4. Re:十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解
（：笑。难道不是扩容加资源吗

--如晚风说
5. Re:解锁硬件潜能：Java向量化计算，性能飙升W倍！
现在编译器都基本上显式的提供了SIMD指令支持，像新版的C#，也有向量化的指令，不过真正要灵活运用，做到效率极致还是最好用C++处理SIMD指令。

--Imageshop

博客园logo
会员
众包
新闻
博问
闪存
赞助商
HarmonyOS
Chat2DB
代码改变世界
搜索
注册
登录
poemyang
为什么我的应用会卡顿？垃圾回收中的STW难题与破解之道
合集 - 技术札纪——有限硬件与无限计算的权衡艺术(50)
1.
书本介绍：技术札纪——有限硬件与无限计算的权衡艺术
07-24
2.
书本大纲：从芯片、分布式到云计算AI时代
07-25
3.
我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？
07-25
4.
我的代码出现幻觉？说好的a = 1； x = b，怎么成了x = b； a = 1？
07-28
5.
为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”
07-29
6.
没有Happens-Before？你的多线程代码就是‘一锅粥’！
07-30
7.
Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法
07-31
8.
a+b=c，处理器一步搞定，Java虚拟机为啥要四步？
08-01
9.
“同声传译”还是“全文翻译”？为何HotSpot虚拟机仍要保留解释器？
08-04
10.
“代码跑着跑着，就变快了？”——揭秘Java性能幕后引擎：即时编译器
08-05
11.
Java编译器优化秘籍：字节码背后的IR魔法与常见技巧
08-06
12.
解锁硬件潜能：Java向量化计算，性能飙升W倍！
08-07
13.
new出来的对象，不一定在堆上？聊聊Java虚拟机的优化技术：逃逸分析
08-08
14.
性能优化之母：为什么说“方法内联”是编译器优化中最关键的一步棋？
08-11
15.
从纳秒到毫秒的“时空之旅”：CPU是如何看待内存与硬盘的？
08-12
16.
硬盘性能提升100倍的秘密：看懂顺序I/O的魔力
08-14
17.
十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解
08-18
18.
Facebook内部都在用的存储引擎，LSM凭什么能硬扛亿级写入流量？
08-21
19.
千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！
08-22
20.
RPC的三大问题：跨语言、跨平台通信的终极解决方案是如何炼成的？
08-27
21.
从文本到二进制：HTTP/2不止于性能，更是对HTTP/1核心语义的传承与革新
08-28
22.
从HPACK到多路复用，揭秘HTTP/2如何终结网络拥堵
08-29
23.
站在巨人的肩膀上：gRPC通过HTTP/2构建云原生时代的通信标准
09-01
24.
gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？
09-03
25.
从JSON到Protobuf，深入序列化方案的选型与原理
09-04
26.
“卧槽，系统又崩了！”——别慌，这也许是你看过最通俗易懂的分布式入门
09-05
27.
海量数据如何“安家”？一文读懂哈希、范围和一致性哈希三大分片策略
09-08
28.
“你还活着吗？” “我没死，只是网卡了！”——来自分布式世界的“生死契约”
09-09
29.
“凭什么说你比我先？”——没有上帝时钟，如何判断“谁先谁后”？
09-12
30.
“鸡蛋不能放一个篮子里”，如何确保千亿数据万无一失？
09-15
31.
系统里数据又“打架”了？让“少数服从多数”来终结这场混乱！
09-18
32.
技术圈的“绯闻女孩”：Gossip是如何把八卦秘密传遍全网的？
09-19
33.
绯闻女孩不只会八卦：从“验明正身”到“抓内鬼”，Gossip的进阶玩法
09-20
34.
从混沌到秩序：Java共享内存模型如何通过显式约束驯服并发？
09-23
35.
一把锁的两种承诺：synchronized如何同时保证互斥与内存可见性？
09-24
36.
从MESA模型到锁升级：synchronized性能逆袭的底层逻辑
09-25
37.
揭秘JUC：volatile与CAS，并发编程的两大基石
09-27
38.
“不要通过共享内存来通信”——深入理解Golang并发模型与CSP理论
10-13
39.
Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
10-14
40.
“一切皆文件”：揭秘LINUX I/O与虚拟内存的底层设计哲学
10-15
41.
你的程序为何卡顿？从LINUX I/O三大模式寻找答案
10-16
42.
单线程如何撑起百万连接？I/O多路复用：现代网络架构的基石
10-17
43.
从C10K到Reactor：事件驱动，如何重塑高并发服务器的网络架构
10-20
44.
职责分离的艺术：剖析主从Reactor模型如何实现极致的并发性能
10-21
45.
“化零为整”的智慧：内存池如何绕过系统调用和GC，构建性能的护城河
10-22
46.
jemalloc思想的极致演绎：深度解构Netty内存池的精妙设计与实现
10-23
47.
为什么Java/Python程序无需关心内存释放？揭秘垃圾回收（GC）的核心概念
10-25
48.
压缩指针：64位系统下，Java虚拟机是如何“偷”回4字节内存的？
10-27
49.
谁生？谁死？从引用计数到可达性分析，洞悉GC的决策逻辑
10-29
50.
为什么我的应用会卡顿？垃圾回收中的STW难题与破解之道
10-30
收起
垃圾回收算法：清除、压缩、复制
可达性分析提供了一种有效的方式，来标记哪些对象死亡，哪些对象还存活。然而，确定哪些对象死亡可以被回收，只是垃圾回收的第一步， 这个过程通常被称为标记（Mark）。接下来，需要一种方法来回收这些死亡对象占用的内存，以便这些内存可以被重新使用。这就是垃圾回收算法的任务。
垃圾回收算法描述了如何有效地回收垃圾对象的内存，同时尽量减少对程序执行的影响。

清除
清除（Sweep）算法的主要操作是将不再活跃的对象的内存标记为可用，并将这些内存信息记录在一个叫做空闲列表（Free List）的数据结构中。当程序需要实例化新的对象时，内存管理模块会从空闲列表中找到可用的内存空间，分配给新对象。
清除算法的主要缺点是可能导致内存碎片化。因为在堆内存中，对象的存储必须是连续的，可能会出现总的空闲内存充足，但无法找到足够大的连续内存空间来存储新的对象的情况。
另一个缺点是清除策略的内存分配效率较低。如果内存是连续的空间，可以通过简单的指针运算，比如指针加法（Pointer Bumping），快速分配内存。但对于清除算法中的空闲列表，需要逐一检查列表中的每一项，找到足够大的空闲内存来存储新的对象，这个过程相对耗时
image

压缩
压缩（Compact）算法的主要操作是将所有存活的对象移动至内存的一端，使这些对象在内存中连续排列，并更新所有指向这些对象的引用。这样，所有未被标记的对象都被挤压到内存的另一端，可以一次性回收。
压缩算法的优点是可以避免内存碎片，因为所有活动对象在压缩时都被紧凑排列。此外，这种算法不需要额外的内存空间，因为所有操作都在原地完成。
然而，压缩算法也有缺点。首先，压缩可能改变对象在内存中的位置，可能影响程序性能。其次，如果活动对象占据了大部分内存，压缩过程可能会非常耗时。
image

复制
复制（Copy）算法的主要操作是将所有活动的对象复制到内存的另一部分（通常称为to-space），并更新所有指向这些对象的引用。复制后，原来的内存区域（即from-space）中的所有对象都被视为垃圾，可以一次性回收。
复制算法的优势在于避免内存碎片，因为所有活动对象在复制时都被紧凑排列。此外，由于只处理活动对象，所以当大部分内存被垃圾对象占据时，此算法效率高。
然而，复制算法也有缺点。首先，它需要额外内存空间存放复制的对象。其次，复制过程可能改变对象在内存中的位置，可能影响程序性能。
image

并发标记：与时间赛跑的追踪游戏
标记阶段是所有追踪式垃圾回收算法的共同特征，这个阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾回收过程，同理可知，如果能够削减这部分停顿时间的话，那收益也将会是系统性的。
为了解决原始标记阶段带来的长时间停顿，多数现代的追踪式垃圾回收算法都会实现三色标记（Tri-color Marking）算法的变种以缩短停顿的时间。三色标记算法将程序中的对象分成白色、黑色和灰色三类。
1）白色对象：不活动对象，没有被其他对象引用，或者从根节点开始无法到达的对象；
2）灰色对象：活动对象，被其他对象引用，或者从根节点开始可以到达的对象。但是，这些对象引用的对象还没有被检查；
3）黑色对象：活动对象，从根节点开始可以到达的对象，而且这些对象引用的对象都已经被检查过了。
image

在垃圾回收过程中，首先将所有对象标记为白色，然后从根节点开始，将可达的对象标记为灰色，然后逐步将灰色对象标记为黑色，并将它们引用的对象标记为灰色。这个过程一直持续到所有活动对象都被标记为黑色，所有不活动对象都被标记为白色。

image

三色标记算法在并发环境下可能会出现问题，这个问题被称为“并发标记的漏标问题”。如下图所示的三色标记过程中，用户程序重新建立了从A对象到D对象的引用，但是因为程序中已经不存在灰色对象了，导致D对象本应被标记为灰色，而被错误地标记为白色，从而在垃圾回收时被错误地回收。

image

为了解决这个问题，可以使用写屏障（Write Barrier）技术。写屏障像是一个钩子方法，当一个对象的引用被修改时，会触发执行一段指令代码，将这个对象重新标记为灰色，以确保不会错过任何需要被标记的对象。这样，就可以在并发环境下正确地进行垃圾回收。

image

增量更新（Incremental Update）和快照在写时复制（Snapshot At The Beginning, SATB）都是垃圾回收中的写屏障技术，但是，它们在处理方式上有所不同。
1）增量更新：写屏障被触发时，如果一个黑色对象引用了一个白色对象，那么这个白色对象会被立即标记为灰色。
2）快照在写时复制：写屏障被触发时，会记录下被修改的引用，而不是立即修改对象的颜色。然后在并发标记结束时，根据这些记录，重新标记那些被错误地标记为非活动对象。

未完待续

很高兴与你相遇！如果你喜欢本文内容，记得关注哦

本文来自博客园，作者：poemyang，转载请注明原文链接：https://www.cnblogs.com/poemyang/p/19176615

合集: 技术札纪——有限硬件与无限计算的权衡艺术
分类: Java虚拟机
标签: java虚拟机, 垃圾回收
好文要顶 关注我 收藏该文 微信分享
poemyang
粉丝 - 21 关注 - 0
+加关注
00
升级成为会员
« 上一篇： 谁生？谁死？从引用计数到可达性分析，洞悉GC的决策逻辑
posted on 2025-10-30 12:16  poemyang  阅读(29)  评论(0)    收藏  举报

刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】鸿蒙应用开发者激励计划，开发上架应用，现金激励超亿元！
【推荐】博客园&小马算力达成战略合作，为开发者注入“算力引擎”
【推荐】2025 HarmonyOS 创新赛正式启动，百万大奖等你来挑战！
【推荐】天翼云智惠上云月，爆款云主机2核2G只要18.8元/3个月起

编辑推荐：
Web优化躬行记（7）——后台上传大批量图优化
从18w到1600w播放量，我的一点思考
从一个普通程序员的角度，聊聊当前环境下，是否还适合做编程
史诗级警报：ASP.NET Core 被曝 CVSS 9.9 分漏洞
一个轻量级C++内存监控及可视化开源库
鸿蒙专区：
开发上架鸿蒙应用，现金激励超亿元！
前端转鸿蒙开发几个比较难受的地方
闯入鸿蒙：浪漫、理想与「草台班子」
3天赚2万！开发者的梦想也可以掷地有声！
Flutter 适配 HarmonyOS 5 开发知识地图
博客园  ©  2004-2025
浙公网安备 33010602011771号 浙ICP备2021040463号-3

<	2025年10月	>
日	一	二	三	四	五	六
28	29	30	1	2	3	4
5	6	7	8	9	10	11
12	13	14	15	16	17	18
19	20	21	22	23	24	25
26	27	28	29	30	31	1
2	3	4	5	6	7	8
导航
博客园
首页
新随笔
联系
订阅 订阅
管理
统计
随笔 - 50
文章 - 0
评论 - 6
阅读 - 20261
公告
昵称： poemyang
园龄： 10年5个月
粉丝： 21
关注： 0
+加关注

搜索
 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
我的标签
rpc(13)
java虚拟机(12)
并发编程(9)
java并发编程(8)
编译原理(7)
java(6)
分布式(6)
网络协议(5)
分布式系统(5)
多线程(5)
更多
合集
技术札纪——有限硬件与无限计算的权衡艺术(50)
随笔分类
Java虚拟机(12)
RPC框架(13)
并发编程艺术(9)
分布式系统之美(8)
高并发系统设计(5)
随笔档案
2025年10月(13)
2025年9月(15)
2025年8月(15)
2025年7月(7)
阅读排行榜
1. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(1819)
2. 为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”(1213)
3. 我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？(828)
4. Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法(787)
5. 硬盘性能提升100倍的秘密：看懂顺序I/O的魔力(739)
评论排行榜
1. Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？(2)
2. 从MESA模型到锁升级：synchronized性能逆袭的底层逻辑(1)
3. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(1)
4. 解锁硬件潜能：Java向量化计算，性能飙升W倍！(1)
5. Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法(1)
推荐排行榜
1. 从JSON到Protobuf，深入序列化方案的选型与原理(3)
2. gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？(2)
3. 千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！(2)
4. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(2)
5. 硬盘性能提升100倍的秘密：看懂顺序I/O的魔力(2)
最新评论
1. Re:Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
@楊柳 msb 是指？...
--poemyang
2. Re:Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
这篇比msb讲的更容易懂点

--楊柳
3. Re:从MESA模型到锁升级：synchronized性能逆袭的底层逻辑
MESA 拼错了，应该是 MESI

--清香白莲素还真
4. Re:十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解
（：笑。难道不是扩容加资源吗

--如晚风说
5. Re:解锁硬件潜能：Java向量化计算，性能飙升W倍！
现在编译器都基本上显式的提供了SIMD指令支持，像新版的C#，也有向量化的指令，不过真正要灵活运用，做到效率极致还是最好用C++处理SIMD指令。

--Imageshop

博客园logo
会员
众包
新闻
博问
闪存
赞助商
HarmonyOS
Chat2DB
代码改变世界
搜索
注册
登录
poemyang
为什么我的应用会卡顿？垃圾回收中的STW难题与破解之道
合集 - 技术札纪——有限硬件与无限计算的权衡艺术(50)
1.
书本介绍：技术札纪——有限硬件与无限计算的权衡艺术
07-24
2.
书本大纲：从芯片、分布式到云计算AI时代
07-25
3.
我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？
07-25
4.
我的代码出现幻觉？说好的a = 1； x = b，怎么成了x = b； a = 1？
07-28
5.
为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”
07-29
6.
没有Happens-Before？你的多线程代码就是‘一锅粥’！
07-30
7.
Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法
07-31
8.
a+b=c，处理器一步搞定，Java虚拟机为啥要四步？
08-01
9.
“同声传译”还是“全文翻译”？为何HotSpot虚拟机仍要保留解释器？
08-04
10.
“代码跑着跑着，就变快了？”——揭秘Java性能幕后引擎：即时编译器
08-05
11.
Java编译器优化秘籍：字节码背后的IR魔法与常见技巧
08-06
12.
解锁硬件潜能：Java向量化计算，性能飙升W倍！
08-07
13.
new出来的对象，不一定在堆上？聊聊Java虚拟机的优化技术：逃逸分析
08-08
14.
性能优化之母：为什么说“方法内联”是编译器优化中最关键的一步棋？
08-11
15.
从纳秒到毫秒的“时空之旅”：CPU是如何看待内存与硬盘的？
08-12
16.
硬盘性能提升100倍的秘密：看懂顺序I/O的魔力
08-14
17.
十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解
08-18
18.
Facebook内部都在用的存储引擎，LSM凭什么能硬扛亿级写入流量？
08-21
19.
千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！
08-22
20.
RPC的三大问题：跨语言、跨平台通信的终极解决方案是如何炼成的？
08-27
21.
从文本到二进制：HTTP/2不止于性能，更是对HTTP/1核心语义的传承与革新
08-28
22.
从HPACK到多路复用，揭秘HTTP/2如何终结网络拥堵
08-29
23.
站在巨人的肩膀上：gRPC通过HTTP/2构建云原生时代的通信标准
09-01
24.
gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？
09-03
25.
从JSON到Protobuf，深入序列化方案的选型与原理
09-04
26.
“卧槽，系统又崩了！”——别慌，这也许是你看过最通俗易懂的分布式入门
09-05
27.
海量数据如何“安家”？一文读懂哈希、范围和一致性哈希三大分片策略
09-08
28.
“你还活着吗？” “我没死，只是网卡了！”——来自分布式世界的“生死契约”
09-09
29.
“凭什么说你比我先？”——没有上帝时钟，如何判断“谁先谁后”？
09-12
30.
“鸡蛋不能放一个篮子里”，如何确保千亿数据万无一失？
09-15
31.
系统里数据又“打架”了？让“少数服从多数”来终结这场混乱！
09-18
32.
技术圈的“绯闻女孩”：Gossip是如何把八卦秘密传遍全网的？
09-19
33.
绯闻女孩不只会八卦：从“验明正身”到“抓内鬼”，Gossip的进阶玩法
09-20
34.
从混沌到秩序：Java共享内存模型如何通过显式约束驯服并发？
09-23
35.
一把锁的两种承诺：synchronized如何同时保证互斥与内存可见性？
09-24
36.
从MESA模型到锁升级：synchronized性能逆袭的底层逻辑
09-25
37.
揭秘JUC：volatile与CAS，并发编程的两大基石
09-27
38.
“不要通过共享内存来通信”——深入理解Golang并发模型与CSP理论
10-13
39.
Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
10-14
40.
“一切皆文件”：揭秘LINUX I/O与虚拟内存的底层设计哲学
10-15
41.
你的程序为何卡顿？从LINUX I/O三大模式寻找答案
10-16
42.
单线程如何撑起百万连接？I/O多路复用：现代网络架构的基石
10-17
43.
从C10K到Reactor：事件驱动，如何重塑高并发服务器的网络架构
10-20
44.
职责分离的艺术：剖析主从Reactor模型如何实现极致的并发性能
10-21
45.
“化零为整”的智慧：内存池如何绕过系统调用和GC，构建性能的护城河
10-22
46.
jemalloc思想的极致演绎：深度解构Netty内存池的精妙设计与实现
10-23
47.
为什么Java/Python程序无需关心内存释放？揭秘垃圾回收（GC）的核心概念
10-25
48.
压缩指针：64位系统下，Java虚拟机是如何“偷”回4字节内存的？
10-27
49.
谁生？谁死？从引用计数到可达性分析，洞悉GC的决策逻辑
10-29
50.
为什么我的应用会卡顿？垃圾回收中的STW难题与破解之道
10-30
收起
垃圾回收算法：清除、压缩、复制
可达性分析提供了一种有效的方式，来标记哪些对象死亡，哪些对象还存活。然而，确定哪些对象死亡可以被回收，只是垃圾回收的第一步， 这个过程通常被称为标记（Mark）。接下来，需要一种方法来回收这些死亡对象占用的内存，以便这些内存可以被重新使用。这就是垃圾回收算法的任务。
垃圾回收算法描述了如何有效地回收垃圾对象的内存，同时尽量减少对程序执行的影响。

清除
清除（Sweep）算法的主要操作是将不再活跃的对象的内存标记为可用，并将这些内存信息记录在一个叫做空闲列表（Free List）的数据结构中。当程序需要实例化新的对象时，内存管理模块会从空闲列表中找到可用的内存空间，分配给新对象。
清除算法的主要缺点是可能导致内存碎片化。因为在堆内存中，对象的存储必须是连续的，可能会出现总的空闲内存充足，但无法找到足够大的连续内存空间来存储新的对象的情况。
另一个缺点是清除策略的内存分配效率较低。如果内存是连续的空间，可以通过简单的指针运算，比如指针加法（Pointer Bumping），快速分配内存。但对于清除算法中的空闲列表，需要逐一检查列表中的每一项，找到足够大的空闲内存来存储新的对象，这个过程相对耗时
image

压缩
压缩（Compact）算法的主要操作是将所有存活的对象移动至内存的一端，使这些对象在内存中连续排列，并更新所有指向这些对象的引用。这样，所有未被标记的对象都被挤压到内存的另一端，可以一次性回收。
压缩算法的优点是可以避免内存碎片，因为所有活动对象在压缩时都被紧凑排列。此外，这种算法不需要额外的内存空间，因为所有操作都在原地完成。
然而，压缩算法也有缺点。首先，压缩可能改变对象在内存中的位置，可能影响程序性能。其次，如果活动对象占据了大部分内存，压缩过程可能会非常耗时。
image

复制
复制（Copy）算法的主要操作是将所有活动的对象复制到内存的另一部分（通常称为to-space），并更新所有指向这些对象的引用。复制后，原来的内存区域（即from-space）中的所有对象都被视为垃圾，可以一次性回收。
复制算法的优势在于避免内存碎片，因为所有活动对象在复制时都被紧凑排列。此外，由于只处理活动对象，所以当大部分内存被垃圾对象占据时，此算法效率高。
然而，复制算法也有缺点。首先，它需要额外内存空间存放复制的对象。其次，复制过程可能改变对象在内存中的位置，可能影响程序性能。
image

并发标记：与时间赛跑的追踪游戏
标记阶段是所有追踪式垃圾回收算法的共同特征，这个阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾回收过程，同理可知，如果能够削减这部分停顿时间的话，那收益也将会是系统性的。
为了解决原始标记阶段带来的长时间停顿，多数现代的追踪式垃圾回收算法都会实现三色标记（Tri-color Marking）算法的变种以缩短停顿的时间。三色标记算法将程序中的对象分成白色、黑色和灰色三类。
1）白色对象：不活动对象，没有被其他对象引用，或者从根节点开始无法到达的对象；
2）灰色对象：活动对象，被其他对象引用，或者从根节点开始可以到达的对象。但是，这些对象引用的对象还没有被检查；
3）黑色对象：活动对象，从根节点开始可以到达的对象，而且这些对象引用的对象都已经被检查过了。
image

在垃圾回收过程中，首先将所有对象标记为白色，然后从根节点开始，将可达的对象标记为灰色，然后逐步将灰色对象标记为黑色，并将它们引用的对象标记为灰色。这个过程一直持续到所有活动对象都被标记为黑色，所有不活动对象都被标记为白色。

image

三色标记算法在并发环境下可能会出现问题，这个问题被称为“并发标记的漏标问题”。如下图所示的三色标记过程中，用户程序重新建立了从A对象到D对象的引用，但是因为程序中已经不存在灰色对象了，导致D对象本应被标记为灰色，而被错误地标记为白色，从而在垃圾回收时被错误地回收。

image

为了解决这个问题，可以使用写屏障（Write Barrier）技术。写屏障像是一个钩子方法，当一个对象的引用被修改时，会触发执行一段指令代码，将这个对象重新标记为灰色，以确保不会错过任何需要被标记的对象。这样，就可以在并发环境下正确地进行垃圾回收。

image

增量更新（Incremental Update）和快照在写时复制（Snapshot At The Beginning, SATB）都是垃圾回收中的写屏障技术，但是，它们在处理方式上有所不同。
1）增量更新：写屏障被触发时，如果一个黑色对象引用了一个白色对象，那么这个白色对象会被立即标记为灰色。
2）快照在写时复制：写屏障被触发时，会记录下被修改的引用，而不是立即修改对象的颜色。然后在并发标记结束时，根据这些记录，重新标记那些被错误地标记为非活动对象。

未完待续

很高兴与你相遇！如果你喜欢本文内容，记得关注哦

本文来自博客园，作者：poemyang，转载请注明原文链接：https://www.cnblogs.com/poemyang/p/19176615

合集: 技术札纪——有限硬件与无限计算的权衡艺术
分类: Java虚拟机
标签: java虚拟机, 垃圾回收
好文要顶 关注我 收藏该文 微信分享
poemyang
粉丝 - 21 关注 - 0
+加关注
00
升级成为会员
« 上一篇： 谁生？谁死？从引用计数到可达性分析，洞悉GC的决策逻辑
posted on 2025-10-30 12:16  poemyang  阅读(29)  评论(0)    收藏  举报

刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】鸿蒙应用开发者激励计划，开发上架应用，现金激励超亿元！
【推荐】博客园&小马算力达成战略合作，为开发者注入“算力引擎”
【推荐】2025 HarmonyOS 创新赛正式启动，百万大奖等你来挑战！
【推荐】天翼云智惠上云月，爆款云主机2核2G只要18.8元/3个月起

编辑推荐：
Web优化躬行记（7）——后台上传大批量图优化
从18w到1600w播放量，我的一点思考
从一个普通程序员的角度，聊聊当前环境下，是否还适合做编程
史诗级警报：ASP.NET Core 被曝 CVSS 9.9 分漏洞
一个轻量级C++内存监控及可视化开源库
鸿蒙专区：
开发上架鸿蒙应用，现金激励超亿元！
前端转鸿蒙开发几个比较难受的地方
闯入鸿蒙：浪漫、理想与「草台班子」
3天赚2万！开发者的梦想也可以掷地有声！
Flutter 适配 HarmonyOS 5 开发知识地图
博客园  ©  2004-2025
浙公网安备 33010602011771号 浙ICP备2021040463号-3

<	2025年10月	>
日	一	二	三	四	五	六
28	29	30	1	2	3	4
5	6	7	8	9	10	11
12	13	14	15	16	17	18
19	20	21	22	23	24	25
26	27	28	29	30	31	1
2	3	4	5	6	7	8
导航
博客园
首页
新随笔
联系
订阅 订阅
管理
统计
随笔 - 50
文章 - 0
评论 - 6
阅读 - 20261
公告
昵称： poemyang
园龄： 10年5个月
粉丝： 21
关注： 0
+加关注

搜索
 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
我的标签
rpc(13)
java虚拟机(12)
并发编程(9)
java并发编程(8)
编译原理(7)
java(6)
分布式(6)
网络协议(5)
分布式系统(5)
多线程(5)
更多
合集
技术札纪——有限硬件与无限计算的权衡艺术(50)
随笔分类
Java虚拟机(12)
RPC框架(13)
并发编程艺术(9)
分布式系统之美(8)
高并发系统设计(5)
随笔档案
2025年10月(13)
2025年9月(15)
2025年8月(15)
2025年7月(7)
阅读排行榜
1. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(1819)
2. 为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”(1213)
3. 我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？(828)
4. Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法(787)
5. 硬盘性能提升100倍的秘密：看懂顺序I/O的魔力(739)
评论排行榜
1. Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？(2)
2. 从MESA模型到锁升级：synchronized性能逆袭的底层逻辑(1)
3. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(1)
4. 解锁硬件潜能：Java向量化计算，性能飙升W倍！(1)
5. Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法(1)
推荐排行榜
1. 从JSON到Protobuf，深入序列化方案的选型与原理(3)
2. gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？(2)
3. 千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！(2)
4. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(2)
5. 硬盘性能提升100倍的秘密：看懂顺序I/O的魔力(2)
最新评论
1. Re:Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
@楊柳 msb 是指？...
--poemyang
2. Re:Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
这篇比msb讲的更容易懂点

--楊柳
3. Re:从MESA模型到锁升级：synchronized性能逆袭的底层逻辑
MESA 拼错了，应该是 MESI

--清香白莲素还真
4. Re:十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解
（：笑。难道不是扩容加资源吗

--如晚风说
5. Re:解锁硬件潜能：Java向量化计算，性能飙升W倍！
现在编译器都基本上显式的提供了SIMD指令支持，像新版的C#，也有向量化的指令，不过真正要灵活运用，做到效率极致还是最好用C++处理SIMD指令。

--Imageshop

博客园logo
会员
众包
新闻
博问
闪存
赞助商
HarmonyOS
Chat2DB
代码改变世界
搜索
注册
登录
poemyang
为什么我的应用会卡顿？垃圾回收中的STW难题与破解之道
合集 - 技术札纪——有限硬件与无限计算的权衡艺术(50)
1.
书本介绍：技术札纪——有限硬件与无限计算的权衡艺术
07-24
2.
书本大纲：从芯片、分布式到云计算AI时代
07-25
3.
我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？
07-25
4.
我的代码出现幻觉？说好的a = 1； x = b，怎么成了x = b； a = 1？
07-28
5.
为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”
07-29
6.
没有Happens-Before？你的多线程代码就是‘一锅粥’！
07-30
7.
Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法
07-31
8.
a+b=c，处理器一步搞定，Java虚拟机为啥要四步？
08-01
9.
“同声传译”还是“全文翻译”？为何HotSpot虚拟机仍要保留解释器？
08-04
10.
“代码跑着跑着，就变快了？”——揭秘Java性能幕后引擎：即时编译器
08-05
11.
Java编译器优化秘籍：字节码背后的IR魔法与常见技巧
08-06
12.
解锁硬件潜能：Java向量化计算，性能飙升W倍！
08-07
13.
new出来的对象，不一定在堆上？聊聊Java虚拟机的优化技术：逃逸分析
08-08
14.
性能优化之母：为什么说“方法内联”是编译器优化中最关键的一步棋？
08-11
15.
从纳秒到毫秒的“时空之旅”：CPU是如何看待内存与硬盘的？
08-12
16.
硬盘性能提升100倍的秘密：看懂顺序I/O的魔力
08-14
17.
十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解
08-18
18.
Facebook内部都在用的存储引擎，LSM凭什么能硬扛亿级写入流量？
08-21
19.
千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！
08-22
20.
RPC的三大问题：跨语言、跨平台通信的终极解决方案是如何炼成的？
08-27
21.
从文本到二进制：HTTP/2不止于性能，更是对HTTP/1核心语义的传承与革新
08-28
22.
从HPACK到多路复用，揭秘HTTP/2如何终结网络拥堵
08-29
23.
站在巨人的肩膀上：gRPC通过HTTP/2构建云原生时代的通信标准
09-01
24.
gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？
09-03
25.
从JSON到Protobuf，深入序列化方案的选型与原理
09-04
26.
“卧槽，系统又崩了！”——别慌，这也许是你看过最通俗易懂的分布式入门
09-05
27.
海量数据如何“安家”？一文读懂哈希、范围和一致性哈希三大分片策略
09-08
28.
“你还活着吗？” “我没死，只是网卡了！”——来自分布式世界的“生死契约”
09-09
29.
“凭什么说你比我先？”——没有上帝时钟，如何判断“谁先谁后”？
09-12
30.
“鸡蛋不能放一个篮子里”，如何确保千亿数据万无一失？
09-15
31.
系统里数据又“打架”了？让“少数服从多数”来终结这场混乱！
09-18
32.
技术圈的“绯闻女孩”：Gossip是如何把八卦秘密传遍全网的？
09-19
33.
绯闻女孩不只会八卦：从“验明正身”到“抓内鬼”，Gossip的进阶玩法
09-20
34.
从混沌到秩序：Java共享内存模型如何通过显式约束驯服并发？
09-23
35.
一把锁的两种承诺：synchronized如何同时保证互斥与内存可见性？
09-24
36.
从MESA模型到锁升级：synchronized性能逆袭的底层逻辑
09-25
37.
揭秘JUC：volatile与CAS，并发编程的两大基石
09-27
38.
“不要通过共享内存来通信”——深入理解Golang并发模型与CSP理论
10-13
39.
Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
10-14
40.
“一切皆文件”：揭秘LINUX I/O与虚拟内存的底层设计哲学
10-15
41.
你的程序为何卡顿？从LINUX I/O三大模式寻找答案
10-16
42.
单线程如何撑起百万连接？I/O多路复用：现代网络架构的基石
10-17
43.
从C10K到Reactor：事件驱动，如何重塑高并发服务器的网络架构
10-20
44.
职责分离的艺术：剖析主从Reactor模型如何实现极致的并发性能
10-21
45.
“化零为整”的智慧：内存池如何绕过系统调用和GC，构建性能的护城河
10-22
46.
jemalloc思想的极致演绎：深度解构Netty内存池的精妙设计与实现
10-23
47.
为什么Java/Python程序无需关心内存释放？揭秘垃圾回收（GC）的核心概念
10-25
48.
压缩指针：64位系统下，Java虚拟机是如何“偷”回4字节内存的？
10-27
49.
谁生？谁死？从引用计数到可达性分析，洞悉GC的决策逻辑
10-29
50.
为什么我的应用会卡顿？垃圾回收中的STW难题与破解之道
10-30
收起
垃圾回收算法：清除、压缩、复制
可达性分析提供了一种有效的方式，来标记哪些对象死亡，哪些对象还存活。然而，确定哪些对象死亡可以被回收，只是垃圾回收的第一步， 这个过程通常被称为标记（Mark）。接下来，需要一种方法来回收这些死亡对象占用的内存，以便这些内存可以被重新使用。这就是垃圾回收算法的任务。
垃圾回收算法描述了如何有效地回收垃圾对象的内存，同时尽量减少对程序执行的影响。

清除
清除（Sweep）算法的主要操作是将不再活跃的对象的内存标记为可用，并将这些内存信息记录在一个叫做空闲列表（Free List）的数据结构中。当程序需要实例化新的对象时，内存管理模块会从空闲列表中找到可用的内存空间，分配给新对象。
清除算法的主要缺点是可能导致内存碎片化。因为在堆内存中，对象的存储必须是连续的，可能会出现总的空闲内存充足，但无法找到足够大的连续内存空间来存储新的对象的情况。
另一个缺点是清除策略的内存分配效率较低。如果内存是连续的空间，可以通过简单的指针运算，比如指针加法（Pointer Bumping），快速分配内存。但对于清除算法中的空闲列表，需要逐一检查列表中的每一项，找到足够大的空闲内存来存储新的对象，这个过程相对耗时
image

压缩
压缩（Compact）算法的主要操作是将所有存活的对象移动至内存的一端，使这些对象在内存中连续排列，并更新所有指向这些对象的引用。这样，所有未被标记的对象都被挤压到内存的另一端，可以一次性回收。
压缩算法的优点是可以避免内存碎片，因为所有活动对象在压缩时都被紧凑排列。此外，这种算法不需要额外的内存空间，因为所有操作都在原地完成。
然而，压缩算法也有缺点。首先，压缩可能改变对象在内存中的位置，可能影响程序性能。其次，如果活动对象占据了大部分内存，压缩过程可能会非常耗时。
image

复制
复制（Copy）算法的主要操作是将所有活动的对象复制到内存的另一部分（通常称为to-space），并更新所有指向这些对象的引用。复制后，原来的内存区域（即from-space）中的所有对象都被视为垃圾，可以一次性回收。
复制算法的优势在于避免内存碎片，因为所有活动对象在复制时都被紧凑排列。此外，由于只处理活动对象，所以当大部分内存被垃圾对象占据时，此算法效率高。
然而，复制算法也有缺点。首先，它需要额外内存空间存放复制的对象。其次，复制过程可能改变对象在内存中的位置，可能影响程序性能。
image

并发标记：与时间赛跑的追踪游戏
标记阶段是所有追踪式垃圾回收算法的共同特征，这个阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾回收过程，同理可知，如果能够削减这部分停顿时间的话，那收益也将会是系统性的。
为了解决原始标记阶段带来的长时间停顿，多数现代的追踪式垃圾回收算法都会实现三色标记（Tri-color Marking）算法的变种以缩短停顿的时间。三色标记算法将程序中的对象分成白色、黑色和灰色三类。
1）白色对象：不活动对象，没有被其他对象引用，或者从根节点开始无法到达的对象；
2）灰色对象：活动对象，被其他对象引用，或者从根节点开始可以到达的对象。但是，这些对象引用的对象还没有被检查；
3）黑色对象：活动对象，从根节点开始可以到达的对象，而且这些对象引用的对象都已经被检查过了。
image

在垃圾回收过程中，首先将所有对象标记为白色，然后从根节点开始，将可达的对象标记为灰色，然后逐步将灰色对象标记为黑色，并将它们引用的对象标记为灰色。这个过程一直持续到所有活动对象都被标记为黑色，所有不活动对象都被标记为白色。

image

三色标记算法在并发环境下可能会出现问题，这个问题被称为“并发标记的漏标问题”。如下图所示的三色标记过程中，用户程序重新建立了从A对象到D对象的引用，但是因为程序中已经不存在灰色对象了，导致D对象本应被标记为灰色，而被错误地标记为白色，从而在垃圾回收时被错误地回收。

image

为了解决这个问题，可以使用写屏障（Write Barrier）技术。写屏障像是一个钩子方法，当一个对象的引用被修改时，会触发执行一段指令代码，将这个对象重新标记为灰色，以确保不会错过任何需要被标记的对象。这样，就可以在并发环境下正确地进行垃圾回收。

image

增量更新（Incremental Update）和快照在写时复制（Snapshot At The Beginning, SATB）都是垃圾回收中的写屏障技术，但是，它们在处理方式上有所不同。
1）增量更新：写屏障被触发时，如果一个黑色对象引用了一个白色对象，那么这个白色对象会被立即标记为灰色。
2）快照在写时复制：写屏障被触发时，会记录下被修改的引用，而不是立即修改对象的颜色。然后在并发标记结束时，根据这些记录，重新标记那些被错误地标记为非活动对象。

未完待续

很高兴与你相遇！如果你喜欢本文内容，记得关注哦

本文来自博客园，作者：poemyang，转载请注明原文链接：https://www.cnblogs.com/poemyang/p/19176615

合集: 技术札纪——有限硬件与无限计算的权衡艺术
分类: Java虚拟机
标签: java虚拟机, 垃圾回收
好文要顶 关注我 收藏该文 微信分享
poemyang
粉丝 - 21 关注 - 0
+加关注
00
升级成为会员
« 上一篇： 谁生？谁死？从引用计数到可达性分析，洞悉GC的决策逻辑
posted on 2025-10-30 12:16  poemyang  阅读(29)  评论(0)    收藏  举报

刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】鸿蒙应用开发者激励计划，开发上架应用，现金激励超亿元！
【推荐】博客园&小马算力达成战略合作，为开发者注入“算力引擎”
【推荐】2025 HarmonyOS 创新赛正式启动，百万大奖等你来挑战！
【推荐】天翼云智惠上云月，爆款云主机2核2G只要18.8元/3个月起

编辑推荐：
Web优化躬行记（7）——后台上传大批量图优化
从18w到1600w播放量，我的一点思考
从一个普通程序员的角度，聊聊当前环境下，是否还适合做编程
史诗级警报：ASP.NET Core 被曝 CVSS 9.9 分漏洞
一个轻量级C++内存监控及可视化开源库
鸿蒙专区：
开发上架鸿蒙应用，现金激励超亿元！
前端转鸿蒙开发几个比较难受的地方
闯入鸿蒙：浪漫、理想与「草台班子」
3天赚2万！开发者的梦想也可以掷地有声！
Flutter 适配 HarmonyOS 5 开发知识地图
博客园  ©  2004-2025
浙公网安备 33010602011771号 浙ICP备2021040463号-3

<	2025年10月	>
日	一	二	三	四	五	六
28	29	30	1	2	3	4
5	6	7	8	9	10	11
12	13	14	15	16	17	18
19	20	21	22	23	24	25
26	27	28	29	30	31	1
2	3	4	5	6	7	8
导航
博客园
首页
新随笔
联系
订阅 订阅
管理
统计
随笔 - 50
文章 - 0
评论 - 6
阅读 - 20261
公告
昵称： poemyang
园龄： 10年5个月
粉丝： 21
关注： 0
+加关注

搜索
 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
我的标签
rpc(13)
java虚拟机(12)
并发编程(9)
java并发编程(8)
编译原理(7)
java(6)
分布式(6)
网络协议(5)
分布式系统(5)
多线程(5)
更多
合集
技术札纪——有限硬件与无限计算的权衡艺术(50)
随笔分类
Java虚拟机(12)
RPC框架(13)
并发编程艺术(9)
分布式系统之美(8)
高并发系统设计(5)
随笔档案
2025年10月(13)
2025年9月(15)
2025年8月(15)
2025年7月(7)
阅读排行榜
1. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(1819)
2. 为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”(1213)
3. 我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？(828)
4. Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法(787)
5. 硬盘性能提升100倍的秘密：看懂顺序I/O的魔力(739)
评论排行榜
1. Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？(2)
2. 从MESA模型到锁升级：synchronized性能逆袭的底层逻辑(1)
3. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(1)
4. 解锁硬件潜能：Java向量化计算，性能飙升W倍！(1)
5. Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法(1)
推荐排行榜
1. 从JSON到Protobuf，深入序列化方案的选型与原理(3)
2. gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？(2)
3. 千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！(2)
4. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(2)
5. 硬盘性能提升100倍的秘密：看懂顺序I/O的魔力(2)
最新评论
1. Re:Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
@楊柳 msb 是指？...
--poemyang
2. Re:Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
这篇比msb讲的更容易懂点

--楊柳
3. Re:从MESA模型到锁升级：synchronized性能逆袭的底层逻辑
MESA 拼错了，应该是 MESI

--清香白莲素还真
4. Re:十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解
（：笑。难道不是扩容加资源吗

--如晚风说
5. Re:解锁硬件潜能：Java向量化计算，性能飙升W倍！
现在编译器都基本上显式的提供了SIMD指令支持，像新版的C#，也有向量化的指令，不过真正要灵活运用，做到效率极致还是最好用C++处理SIMD指令。

--Imageshop

博客园logo
会员
众包
新闻
博问
闪存
赞助商
HarmonyOS
Chat2DB
代码改变世界
搜索
注册
登录
poemyang
为什么我的应用会卡顿？垃圾回收中的STW难题与破解之道
合集 - 技术札纪——有限硬件与无限计算的权衡艺术(50)
1.
书本介绍：技术札纪——有限硬件与无限计算的权衡艺术
07-24
2.
书本大纲：从芯片、分布式到云计算AI时代
07-25
3.
我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？
07-25
4.
我的代码出现幻觉？说好的a = 1； x = b，怎么成了x = b； a = 1？
07-28
5.
为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”
07-29
6.
没有Happens-Before？你的多线程代码就是‘一锅粥’！
07-30
7.
Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法
07-31
8.
a+b=c，处理器一步搞定，Java虚拟机为啥要四步？
08-01
9.
“同声传译”还是“全文翻译”？为何HotSpot虚拟机仍要保留解释器？
08-04
10.
“代码跑着跑着，就变快了？”——揭秘Java性能幕后引擎：即时编译器
08-05
11.
Java编译器优化秘籍：字节码背后的IR魔法与常见技巧
08-06
12.
解锁硬件潜能：Java向量化计算，性能飙升W倍！
08-07
13.
new出来的对象，不一定在堆上？聊聊Java虚拟机的优化技术：逃逸分析
08-08
14.
性能优化之母：为什么说“方法内联”是编译器优化中最关键的一步棋？
08-11
15.
从纳秒到毫秒的“时空之旅”：CPU是如何看待内存与硬盘的？
08-12
16.
硬盘性能提升100倍的秘密：看懂顺序I/O的魔力
08-14
17.
十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解
08-18
18.
Facebook内部都在用的存储引擎，LSM凭什么能硬扛亿级写入流量？
08-21
19.
千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！
08-22
20.
RPC的三大问题：跨语言、跨平台通信的终极解决方案是如何炼成的？
08-27
21.
从文本到二进制：HTTP/2不止于性能，更是对HTTP/1核心语义的传承与革新
08-28
22.
从HPACK到多路复用，揭秘HTTP/2如何终结网络拥堵
08-29
23.
站在巨人的肩膀上：gRPC通过HTTP/2构建云原生时代的通信标准
09-01
24.
gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？
09-03
25.
从JSON到Protobuf，深入序列化方案的选型与原理
09-04
26.
“卧槽，系统又崩了！”——别慌，这也许是你看过最通俗易懂的分布式入门
09-05
27.
海量数据如何“安家”？一文读懂哈希、范围和一致性哈希三大分片策略
09-08
28.
“你还活着吗？” “我没死，只是网卡了！”——来自分布式世界的“生死契约”
09-09
29.
“凭什么说你比我先？”——没有上帝时钟，如何判断“谁先谁后”？
09-12
30.
“鸡蛋不能放一个篮子里”，如何确保千亿数据万无一失？
09-15
31.
系统里数据又“打架”了？让“少数服从多数”来终结这场混乱！
09-18
32.
技术圈的“绯闻女孩”：Gossip是如何把八卦秘密传遍全网的？
09-19
33.
绯闻女孩不只会八卦：从“验明正身”到“抓内鬼”，Gossip的进阶玩法
09-20
34.
从混沌到秩序：Java共享内存模型如何通过显式约束驯服并发？
09-23
35.
一把锁的两种承诺：synchronized如何同时保证互斥与内存可见性？
09-24
36.
从MESA模型到锁升级：synchronized性能逆袭的底层逻辑
09-25
37.
揭秘JUC：volatile与CAS，并发编程的两大基石
09-27
38.
“不要通过共享内存来通信”——深入理解Golang并发模型与CSP理论
10-13
39.
Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
10-14
40.
“一切皆文件”：揭秘LINUX I/O与虚拟内存的底层设计哲学
10-15
41.
你的程序为何卡顿？从LINUX I/O三大模式寻找答案
10-16
42.
单线程如何撑起百万连接？I/O多路复用：现代网络架构的基石
10-17
43.
从C10K到Reactor：事件驱动，如何重塑高并发服务器的网络架构
10-20
44.
职责分离的艺术：剖析主从Reactor模型如何实现极致的并发性能
10-21
45.
“化零为整”的智慧：内存池如何绕过系统调用和GC，构建性能的护城河
10-22
46.
jemalloc思想的极致演绎：深度解构Netty内存池的精妙设计与实现
10-23
47.
为什么Java/Python程序无需关心内存释放？揭秘垃圾回收（GC）的核心概念
10-25
48.
压缩指针：64位系统下，Java虚拟机是如何“偷”回4字节内存的？
10-27
49.
谁生？谁死？从引用计数到可达性分析，洞悉GC的决策逻辑
10-29
50.
为什么我的应用会卡顿？垃圾回收中的STW难题与破解之道
10-30
收起
垃圾回收算法：清除、压缩、复制
可达性分析提供了一种有效的方式，来标记哪些对象死亡，哪些对象还存活。然而，确定哪些对象死亡可以被回收，只是垃圾回收的第一步， 这个过程通常被称为标记（Mark）。接下来，需要一种方法来回收这些死亡对象占用的内存，以便这些内存可以被重新使用。这就是垃圾回收算法的任务。
垃圾回收算法描述了如何有效地回收垃圾对象的内存，同时尽量减少对程序执行的影响。

清除
清除（Sweep）算法的主要操作是将不再活跃的对象的内存标记为可用，并将这些内存信息记录在一个叫做空闲列表（Free List）的数据结构中。当程序需要实例化新的对象时，内存管理模块会从空闲列表中找到可用的内存空间，分配给新对象。
清除算法的主要缺点是可能导致内存碎片化。因为在堆内存中，对象的存储必须是连续的，可能会出现总的空闲内存充足，但无法找到足够大的连续内存空间来存储新的对象的情况。
另一个缺点是清除策略的内存分配效率较低。如果内存是连续的空间，可以通过简单的指针运算，比如指针加法（Pointer Bumping），快速分配内存。但对于清除算法中的空闲列表，需要逐一检查列表中的每一项，找到足够大的空闲内存来存储新的对象，这个过程相对耗时
image

压缩
压缩（Compact）算法的主要操作是将所有存活的对象移动至内存的一端，使这些对象在内存中连续排列，并更新所有指向这些对象的引用。这样，所有未被标记的对象都被挤压到内存的另一端，可以一次性回收。
压缩算法的优点是可以避免内存碎片，因为所有活动对象在压缩时都被紧凑排列。此外，这种算法不需要额外的内存空间，因为所有操作都在原地完成。
然而，压缩算法也有缺点。首先，压缩可能改变对象在内存中的位置，可能影响程序性能。其次，如果活动对象占据了大部分内存，压缩过程可能会非常耗时。
image

复制
复制（Copy）算法的主要操作是将所有活动的对象复制到内存的另一部分（通常称为to-space），并更新所有指向这些对象的引用。复制后，原来的内存区域（即from-space）中的所有对象都被视为垃圾，可以一次性回收。
复制算法的优势在于避免内存碎片，因为所有活动对象在复制时都被紧凑排列。此外，由于只处理活动对象，所以当大部分内存被垃圾对象占据时，此算法效率高。
然而，复制算法也有缺点。首先，它需要额外内存空间存放复制的对象。其次，复制过程可能改变对象在内存中的位置，可能影响程序性能。
image

并发标记：与时间赛跑的追踪游戏
标记阶段是所有追踪式垃圾回收算法的共同特征，这个阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾回收过程，同理可知，如果能够削减这部分停顿时间的话，那收益也将会是系统性的。
为了解决原始标记阶段带来的长时间停顿，多数现代的追踪式垃圾回收算法都会实现三色标记（Tri-color Marking）算法的变种以缩短停顿的时间。三色标记算法将程序中的对象分成白色、黑色和灰色三类。
1）白色对象：不活动对象，没有被其他对象引用，或者从根节点开始无法到达的对象；
2）灰色对象：活动对象，被其他对象引用，或者从根节点开始可以到达的对象。但是，这些对象引用的对象还没有被检查；
3）黑色对象：活动对象，从根节点开始可以到达的对象，而且这些对象引用的对象都已经被检查过了。
image

在垃圾回收过程中，首先将所有对象标记为白色，然后从根节点开始，将可达的对象标记为灰色，然后逐步将灰色对象标记为黑色，并将它们引用的对象标记为灰色。这个过程一直持续到所有活动对象都被标记为黑色，所有不活动对象都被标记为白色。

image

三色标记算法在并发环境下可能会出现问题，这个问题被称为“并发标记的漏标问题”。如下图所示的三色标记过程中，用户程序重新建立了从A对象到D对象的引用，但是因为程序中已经不存在灰色对象了，导致D对象本应被标记为灰色，而被错误地标记为白色，从而在垃圾回收时被错误地回收。

image

为了解决这个问题，可以使用写屏障（Write Barrier）技术。写屏障像是一个钩子方法，当一个对象的引用被修改时，会触发执行一段指令代码，将这个对象重新标记为灰色，以确保不会错过任何需要被标记的对象。这样，就可以在并发环境下正确地进行垃圾回收。

image

增量更新（Incremental Update）和快照在写时复制（Snapshot At The Beginning, SATB）都是垃圾回收中的写屏障技术，但是，它们在处理方式上有所不同。
1）增量更新：写屏障被触发时，如果一个黑色对象引用了一个白色对象，那么这个白色对象会被立即标记为灰色。
2）快照在写时复制：写屏障被触发时，会记录下被修改的引用，而不是立即修改对象的颜色。然后在并发标记结束时，根据这些记录，重新标记那些被错误地标记为非活动对象。

未完待续

很高兴与你相遇！如果你喜欢本文内容，记得关注哦

本文来自博客园，作者：poemyang，转载请注明原文链接：https://www.cnblogs.com/poemyang/p/19176615

合集: 技术札纪——有限硬件与无限计算的权衡艺术
分类: Java虚拟机
标签: java虚拟机, 垃圾回收
好文要顶 关注我 收藏该文 微信分享
poemyang
粉丝 - 21 关注 - 0
+加关注
00
升级成为会员
« 上一篇： 谁生？谁死？从引用计数到可达性分析，洞悉GC的决策逻辑
posted on 2025-10-30 12:16  poemyang  阅读(29)  评论(0)    收藏  举报

刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】鸿蒙应用开发者激励计划，开发上架应用，现金激励超亿元！
【推荐】博客园&小马算力达成战略合作，为开发者注入“算力引擎”
【推荐】2025 HarmonyOS 创新赛正式启动，百万大奖等你来挑战！
【推荐】天翼云智惠上云月，爆款云主机2核2G只要18.8元/3个月起

编辑推荐：
Web优化躬行记（7）——后台上传大批量图优化
从18w到1600w播放量，我的一点思考
从一个普通程序员的角度，聊聊当前环境下，是否还适合做编程
史诗级警报：ASP.NET Core 被曝 CVSS 9.9 分漏洞
一个轻量级C++内存监控及可视化开源库
鸿蒙专区：
开发上架鸿蒙应用，现金激励超亿元！
前端转鸿蒙开发几个比较难受的地方
闯入鸿蒙：浪漫、理想与「草台班子」
3天赚2万！开发者的梦想也可以掷地有声！
Flutter 适配 HarmonyOS 5 开发知识地图
博客园  ©  2004-2025
浙公网安备 33010602011771号 浙ICP备2021040463号-3

<	2025年10月	>
日	一	二	三	四	五	六
28	29	30	1	2	3	4
5	6	7	8	9	10	11
12	13	14	15	16	17	18
19	20	21	22	23	24	25
26	27	28	29	30	31	1
2	3	4	5	6	7	8
导航
博客园
首页
新随笔
联系
订阅 订阅
管理
统计
随笔 - 50
文章 - 0
评论 - 6
阅读 - 20261
公告
昵称： poemyang
园龄： 10年5个月
粉丝： 21
关注： 0
+加关注

搜索
 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
我的标签
rpc(13)
java虚拟机(12)
并发编程(9)
java并发编程(8)
编译原理(7)
java(6)
分布式(6)
网络协议(5)
分布式系统(5)
多线程(5)
更多
合集
技术札纪——有限硬件与无限计算的权衡艺术(50)
随笔分类
Java虚拟机(12)
RPC框架(13)
并发编程艺术(9)
分布式系统之美(8)
高并发系统设计(5)
随笔档案
2025年10月(13)
2025年9月(15)
2025年8月(15)
2025年7月(7)
阅读排行榜
1. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(1819)
2. 为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”(1213)
3. 我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？(828)
4. Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法(787)
5. 硬盘性能提升100倍的秘密：看懂顺序I/O的魔力(739)
评论排行榜
1. Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？(2)
2. 从MESA模型到锁升级：synchronized性能逆袭的底层逻辑(1)
3. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(1)
4. 解锁硬件潜能：Java向量化计算，性能飙升W倍！(1)
5. Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法(1)
推荐排行榜
1. 从JSON到Protobuf，深入序列化方案的选型与原理(3)
2. gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？(2)
3. 千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！(2)
4. 十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解(2)
5. 硬盘性能提升100倍的秘密：看懂顺序I/O的魔力(2)
最新评论
1. Re:Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
@楊柳 msb 是指？...
--poemyang
2. Re:Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？
这篇比msb讲的更容易懂点

--楊柳
3. Re:从MESA模型到锁升级：synchronized性能逆袭的底层逻辑
MESA 拼错了，应该是 MESI

--清香白莲素还真
4. Re:十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解
（：笑。难道不是扩容加资源吗

--如晚风说
5. Re:解锁硬件潜能：Java向量化计算，性能飙升W倍！
现在编译器都基本上显式的提供了SIMD指令支持，像新版的C#，也有向量化的指令，不过真正要灵活运用，做到效率极致还是最好用C++处理SIMD指令。

--Imageshop